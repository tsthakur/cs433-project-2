import numpy as np
import re
from pathlib import Path

class LogReader:
    """A simple program for reading log files generated by LAMMPS simulations.
    Stores log file content in a dictionary for easy variable extraction.

    :param logFilePath: Full path to the log file
    :type logFilePath: str or pathlib.PosixPath
    """

    def __init__(self, logFilePath):
        if not isinstance(logFilePath, str):
            raise TypeError('Parameter logFilePath must be of type str')

        with open(logFilePath, 'r', newline='\n') as fileOpen:
            logData = fileOpen.read().replace('\r', '')

        startMarker = 'Per MPI rank'
        endMarker = 'Loop time'
        haltMarker = 'Fix halt'
        self.thermoDataDict = {}

        # Clean up log file by removing extra spaces and tabs
        logData = re.sub(' +', ' ', logData)
        logData = re.sub('\t', ' ', logData)
        logData = logData[[m.start() for m in re.finditer(startMarker, logData)][0]:]

        # Find indices for the start of the line above the thermo data
        lineAboveThermoIndices = [m.start() for m in re.finditer(startMarker, logData)]

        # Number of thermo datasets
        self.numThermoDatasets = len(lineAboveThermoIndices)

        # Index of column titles
        thermoTitlesStartIndices = [
            logData.find('\n', lineAboveThermoIndices[i]) + 1
            for i in range(self.numThermoDatasets)
        ]

        # Store titles to use as keys in the dictionary
        thermoTitlesEndIndex = logData.find('\n', thermoTitlesStartIndices[0])
        thermoTitles = logData[thermoTitlesStartIndices[0]:thermoTitlesEndIndex].split()

        numColumns = len(thermoTitles)

        thermoStartIndices = [
            logData.find('\n', thermoTitlesStartIndices[i]) + 1
            for i in range(self.numThermoDatasets)
        ]

        # Find indices for the start of the line above and below the thermo data
        lineBelowThermoIndices = [
            m.start() - 2 for m in re.finditer(endMarker, logData)  # -2 to remove \n and space
        ]

        haltIndex = logData.find(haltMarker, thermoStartIndices[-1])

        if haltIndex != -1:
            if len(lineBelowThermoIndices) == len(thermoStartIndices):
                lineBelowThermoIndices[-1] = haltIndex - 1
            elif len(lineBelowThermoIndices) < len(thermoStartIndices):
                lineBelowThermoIndices.append(haltIndex - 1)

        if len(lineBelowThermoIndices) < len(thermoStartIndices):
            # If there is no end detected (typically MPI_Abort / time ran out)
            lineBelowThermoIndices.append(-1)

        self.thermoDataDict = {key: [] for key in thermoTitles}
        for i in range(self.numThermoDatasets):
            lines = logData[thermoStartIndices[i]:lineBelowThermoIndices[i]].split('\n')

            for line in lines:
                elements = line.split()
                for title, element in zip(thermoTitles, elements):
                    self.thermoDataDict[title].append(float(element))

    def __call__(self):
        """Returns the dictionary containing log file columns.

        :returns thermoDataDict: Columns of log file
        :rtype thermoDataDict: dict
        """
        return self.thermoDataDict

    def get_header(self, columnName):
        """Returns a specific column from the log file.

        :param columnName: Specifies which values from log file to extract
        :type columnName: str
        :returns values: Corresponding values of parameters data
        :rtype values: list
        """
        if not isinstance(columnName, str):
            raise TypeError(f'Argument columnName is of type {type(columnName)}, must be of type str')
        return self.thermoDataDict[columnName]

    def get_header_names(self):
        """Returns the headers of the columns of data, i.e., what thermodynamic
        data has been found present in the logfile.

        :returns headers: Headers of the columns of thermo data
        :rtype headers: list
        """
        headers = self.thermoDataDict.keys()
        return headers
